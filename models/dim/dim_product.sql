-- models/dim/dim_product.sql
-- Dimension table for products (VSC, GAP, etc.)

-- 1. Define Table Structure
CREATE TABLE IF NOT EXISTS gold.finance.dim_product (
  product_key BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1),
  product_id_source STRING, -- Natural key from source (e.g., vsc_type, gap_type)
  product_name STRING,
  product_category STRING, -- e.g., VSC, GAP, Finance Add-on
  -- Add other relevant product attributes if available (e.g., provider)
  _source_table STRING, -- Metadata: Source table name
  _load_timestamp TIMESTAMP -- Metadata: When the record was loaded/updated
)
USING DELTA
COMMENT 'Dimension table for products like VSC and GAP.'
TBLPROPERTIES (
    'delta.autoOptimize.optimizeWrite' = 'true',
    'delta.autoOptimize.autoCompact' = 'true',
    'delta.columnMapping.mode' = 'name' -- Required for IDENTITY columns
);

-- Add constraint if product_id_source should be unique (requires DBR 11.1+ or Unity Catalog)
-- ALTER TABLE gold.finance.dim_product ADD CONSTRAINT dim_product_id_unique UNIQUE (product_id_source);

-- 2. Merge incremental changes
MERGE INTO gold.finance.dim_product AS target
USING (
  -- Source query: Select distinct product types from the source table
  -- This currently only looks at vsc_type. Needs enhancement to include GAP and potentially others.
  SELECT DISTINCT
    vsc_type AS product_id_source,
    -- Derive product name - enhance this logic
    CASE
      WHEN vsc_type IS NULL THEN 'None'
      WHEN vsc_type = '' THEN 'Unknown'
      ELSE vsc_type
    END AS product_name,
    -- Derive product category - enhance this logic
    CASE
      WHEN vsc_type IS NULL THEN 'None'
      WHEN vsc_type LIKE '%VSC%' THEN 'VSC'
      ELSE 'Other Finance Product' -- Default category
    END AS product_category,
    'silver.deal.big_deal' AS _source_table
  FROM silver.deal.big_deal
  -- Consider adding GAP products:
  -- UNION
  -- SELECT DISTINCT gap_product_field AS product_id_source, ... FROM source WHERE gap_product_field IS NOT NULL
) AS source
-- Match on source ID, handling NULLs appropriately if 'None' should be a distinct record
ON target.product_id_source <=> source.product_id_source -- NULL-safe equality check

-- Update existing products if attributes change (e.g., name/category mapping logic improves)
WHEN MATCHED AND (
    target.product_name <> source.product_name OR
    target.product_category <> source.product_category
  ) THEN
  UPDATE SET
    target.product_name = source.product_name,
    target.product_category = source.product_category,
    target._source_table = source._source_table,
    target._load_timestamp = CURRENT_TIMESTAMP()

-- Insert new product types found (product_key is auto-generated)
WHEN NOT MATCHED THEN
  INSERT (
    product_id_source,
    product_name,
    product_category,
    _source_table,
    _load_timestamp
  )
  VALUES (
    source.product_id_source,
    source.product_name,
    source.product_category,
    source._source_table,
    CURRENT_TIMESTAMP()
  );

-- Note: This DDL structure is refined but requires detailed ETL logic.
-- Populating it requires an ETL process that handles:
-- 1. Sourcing from silver.deal.big_deal, bronze.leaseend_db_public.financial_infos, and potentially bronze.leaseend_db_public.products.
-- 2. Deriving product_category, product_name, term_months/miles.
-- 3. Creating a stable product_source_identifier.
-- 4. Implementing SCD Type 2 logic.
-- 5. Handling NULLs and data cleansing (e.g., parsing term strings). 