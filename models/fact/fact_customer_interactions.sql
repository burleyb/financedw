-- models/fact/fact_customer_interactions.sql
-- Fact table for customer interactions (e.g., calls, emails, meetings from Hubspot)

-- 1. Define Table Structure
CREATE TABLE IF NOT EXISTS gold.finance.fact_customer_interactions (
  interaction_key BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1), -- Added surrogate key
  engagement_id_source BIGINT NOT NULL, -- Natural key from source (Hubspot engagement ID)
  driver_key BIGINT, -- FK to dim_driver
  employee_key BIGINT, -- FK to dim_employee
  interaction_date_key INT, -- FK to dim_date
  interaction_type STRING, -- e.g., CALL, EMAIL, MEETING
  activity_type STRING, -- Hubspot specific activity type
  duration_seconds BIGINT, -- Duration in seconds
  interaction_count INT, -- Usually 1 per interaction record
  interaction_timestamp TIMESTAMP, -- Start timestamp of the interaction
  -- Add other relevant measures/attributes
  _source_table STRING, -- Metadata: Source table name
  _load_timestamp TIMESTAMP -- Metadata: When the record was loaded/updated
)
USING DELTA
COMMENT 'Fact table containing driver interaction events, primarily from Hubspot engagements.'
PARTITIONED BY (interaction_date_key) -- Example partitioning
TBLPROPERTIES (
    'delta.autoOptimize.optimizeWrite' = 'true',
    'delta.autoOptimize.autoCompact' = 'true',
    'delta.columnMapping.mode' = 'name' -- Required for IDENTITY columns
);

-- 2. Merge incremental changes
MERGE INTO gold.finance.fact_customer_interactions AS target
USING (
  -- Source query: Select interaction data and join dimensions
  -- Note: Ensure source tables (bronze.hubspot.*) exist and columns match.
  SELECT
    e.engagement_id AS engagement_id_source,
    COALESCE(dr.driver_key, -1) AS driver_key,
    COALESCE(emp.employee_key, -1) AS employee_key,
    COALESCE(dd.date_key, -1) AS interaction_date_key,
    e.type AS interaction_type,
    e.activity_type,
    -- Calculate duration in seconds
    CASE
      WHEN e.engagement_ended_at IS NOT NULL AND e.engagement_started_at IS NOT NULL
      THEN unix_timestamp(e.engagement_ended_at) - unix_timestamp(e.engagement_started_at)
      ELSE NULL
    END AS duration_seconds,
    1 AS interaction_count,
    e.engagement_started_at as interaction_timestamp,
    'bronze.hubspot.engagement' AS _source_table
    -- Consider using GREATEST(e.engagement_updated_at, huc.last_modified_date, ...) for incremental filtering
    -- GREATEST(e.engagement_updated_at, huc.last_modified_date) AS _source_updated_at

  FROM bronze.hubspot.engagement e
  -- Joining Hubspot contacts to get email/ID for driver lookup
  LEFT JOIN bronze.hubspot.engagement_contact ec ON e.engagement_id = ec.engagement_id
  LEFT JOIN bronze.hubspot.contact huc ON ec.contact_id = huc.id
  -- Join to Driver Dim: Using email currently. Joining on driver_id_source would be more robust if available in Hubspot contact data.
  LEFT JOIN gold.finance.dim_driver dr ON huc.property_email = dr.email
  -- Join to Employee Dim: Uses owner_id. Ensure owner_id maps correctly to employee_id_source in dim_employee.
  LEFT JOIN gold.finance.dim_employee emp ON CAST(e.owner_id AS STRING) = emp.employee_id_source
  -- Join to Date Dim
  LEFT JOIN gold.finance.dim_date dd ON DATE(e.engagement_started_at) = dd.date

  WHERE e.engagement_id IS NOT NULL
  -- Optional: Filter for recent engagements if using incremental source filtering
  -- AND GREATEST(e.engagement_updated_at, huc.last_modified_date) > (SELECT MAX(_load_timestamp) FROM gold.finance.fact_customer_interactions)

  -- Handle potential duplicates if one engagement links to multiple contacts/owners incorrectly
  QUALIFY ROW_NUMBER() OVER (PARTITION BY e.engagement_id ORDER BY huc.last_modified_date DESC) = 1

) AS source
-- Match on the natural key from the source system
ON target.engagement_id_source = source.engagement_id_source

-- Update existing interactions if dimension keys or attributes change
WHEN MATCHED AND (
    target.driver_key <> source.driver_key OR
    target.employee_key <> source.employee_key OR
    target.interaction_date_key <> source.interaction_date_key OR
    target.interaction_type <> source.interaction_type OR
    target.activity_type <> source.activity_type OR
    target.duration_seconds <> source.duration_seconds OR
    target.interaction_timestamp <> source.interaction_timestamp
    -- Add other checks as needed
  ) THEN
  UPDATE SET
    target.driver_key = source.driver_key,
    target.employee_key = source.employee_key,
    target.interaction_date_key = source.interaction_date_key,
    target.interaction_type = source.interaction_type,
    target.activity_type = source.activity_type,
    target.duration_seconds = source.duration_seconds,
    target.interaction_count = source.interaction_count, -- Should remain 1
    target.interaction_timestamp = source.interaction_timestamp,
    target._source_table = source._source_table,
    target._load_timestamp = CURRENT_TIMESTAMP()

-- Insert new interactions (interaction_key is auto-generated)
WHEN NOT MATCHED THEN
  INSERT (
    engagement_id_source,
    driver_key,
    employee_key,
    interaction_date_key,
    interaction_type,
    activity_type,
    duration_seconds,
    interaction_count,
    interaction_timestamp,
    _source_table,
    _load_timestamp
  )
  VALUES (
    source.engagement_id_source,
    source.driver_key,
    source.employee_key,
    source.interaction_date_key,
    source.interaction_type,
    source.activity_type,
    source.duration_seconds,
    source.interaction_count,
    source.interaction_timestamp,
    source._source_table,
    CURRENT_TIMESTAMP()
  );